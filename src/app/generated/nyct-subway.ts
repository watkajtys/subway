// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.1
//   protoc               v4.25.3
// source: nyct-subway.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { TimeRange } from "./gtfs-realtime";

export const protobufPackage = "";

export interface TripReplacementPeriod {
  /** The replacement period is for this route */
  routeId?:
    | string
    | undefined;
  /**
   * The start time is omitted, the end time is currently now + 30 minutes for
   * all routes of the A division
   */
  replacementPeriod?: TimeRange | undefined;
}

/** NYCT Subway extensions for the feed header */
export interface NyctFeedHeader {
  /**
   * Version of the NYCT Subway extensions
   * The current version is 1.0
   */
  nyctSubwayVersion: string;
  /**
   * For the NYCT Subway, the GTFS-realtime feed replaces any scheduled
   * trip within the trip_replacement_period.
   * This feed is a full dataset, it contains all trips starting
   * in the trip_replacement_period. If a trip from the static GTFS is not
   * found in the GTFS-realtime feed, it should be considered as cancelled.
   * The replacement period can be different for each route, so here is
   * a list of the routes where the trips in the feed replace all
   * scheduled trips within the replacement period.
   */
  tripReplacementPeriod: TripReplacementPeriod[];
}

/** NYCT Subway extensions for the trip descriptor */
export interface NyctTripDescriptor {
  /**
   * The nyct_train_id is meant for internal use only. It provides an
   * easy way to associated GTFS-realtime trip identifiers with NYCT rail
   * operations identifier
   *
   * The ATS office system assigns unique train identification (Train ID) to
   * each train operating within or ready to enter the mainline of the
   * monitored territory. An example of this is 06 0123+ PEL/BBR and is decoded
   * as follows:
   *
   * The first character represents the trip type designator. 0 identifies a
   * scheduled revenue trip. Other revenue trip values that are a result of a
   * change to the base schedule include; [= reroute], [/ skip stop], [$ turn
   * train] also known as shortly lined service.
   *
   * The second character 6 represents the trip line i.e. number 6 train The
   * third set of characters identify the decoded origin time. The last
   * character may be blank "on the whole minute" or + "30 seconds"
   *
   * Note: Origin times will not change when there is a trip type change.  This
   * is followed by a three character "Origin Location" / "Destination
   * Location"
   */
  trainId?:
    | string
    | undefined;
  /**
   * This trip has been assigned to a physical train. If true, this trip is
   * already underway or most likely will depart shortly.
   *
   * Train Assignment is a function of the Automatic Train Supervision (ATS)
   * office system used by NYCT Rail Operations to monitor and track train
   * movements. ATS provides the ability to "assign" the nyct_train_id
   * attribute when a physical train is at its origin terminal. These assigned
   * trips have the is_assigned field set in the TripDescriptor.
   *
   * When a train is at a terminal but has not been given a work program it is
   * declared unassigned and is tagged as such. Unassigned trains can be moved
   * to a storage location or assigned a nyct_train_id when a determination for
   * service is made.
   */
  isAssigned?:
    | boolean
    | undefined;
  /**
   * Uptown and Bronx-bound trains are moving NORTH.
   * Times Square Shuttle to Grand Central is also northbound.
   *
   * Downtown and Brooklyn-bound trains are moving SOUTH.
   * Times Square Shuttle to Times Square is also southbound.
   *
   * EAST and WEST are not used currently.
   */
  direction?: NyctTripDescriptor_Direction | undefined;
}

/** The direction the train is moving. */
export enum NyctTripDescriptor_Direction {
  NORTH = 1,
  EAST = 2,
  SOUTH = 3,
  WEST = 4,
  UNRECOGNIZED = -1,
}

export function nyctTripDescriptor_DirectionFromJSON(object: any): NyctTripDescriptor_Direction {
  switch (object) {
    case 1:
    case "NORTH":
      return NyctTripDescriptor_Direction.NORTH;
    case 2:
    case "EAST":
      return NyctTripDescriptor_Direction.EAST;
    case 3:
    case "SOUTH":
      return NyctTripDescriptor_Direction.SOUTH;
    case 4:
    case "WEST":
      return NyctTripDescriptor_Direction.WEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NyctTripDescriptor_Direction.UNRECOGNIZED;
  }
}

export function nyctTripDescriptor_DirectionToJSON(object: NyctTripDescriptor_Direction): string {
  switch (object) {
    case NyctTripDescriptor_Direction.NORTH:
      return "NORTH";
    case NyctTripDescriptor_Direction.EAST:
      return "EAST";
    case NyctTripDescriptor_Direction.SOUTH:
      return "SOUTH";
    case NyctTripDescriptor_Direction.WEST:
      return "WEST";
    case NyctTripDescriptor_Direction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** NYCT Subway extensions for the stop time update */
export interface NyctStopTimeUpdate {
  /**
   * Provides the planned station arrival track. The following is the Manhattan
   * track configurations:
   * 1: southbound local
   * 2: southbound express
   * 3: northbound express
   * 4: northbound local
   *
   * In the Bronx (except Dyre Ave line)
   * M: bi-directional express (in the AM express to Manhattan, in the PM
   * express away).
   *
   * The Dyre Ave line is configured:
   * 1: southbound
   * 2: northbound
   * 3: bi-directional
   */
  scheduledTrack?:
    | string
    | undefined;
  /**
   * This is the actual track that the train is operating on and can be used to
   * determine if a train is operating according to its current schedule
   * (plan).
   *
   * The actual track is known only shortly before the train reaches a station,
   * typically not before it leaves the previous station. Therefore, the NYCT
   * feed sets this field only for the first station of the remaining trip.
   *
   * Different actual and scheduled track is the result of manually rerouting a
   * train off it scheduled path.  When this occurs, prediction data may become
   * unreliable since the train is no longer operating in accordance to its
   * schedule.  The rules engine for the 'countdown' clocks will remove this
   * train from all schedule stations.
   */
  actualTrack?: string | undefined;
}

function createBaseTripReplacementPeriod(): TripReplacementPeriod {
  return { routeId: "", replacementPeriod: undefined };
}

export const TripReplacementPeriod: MessageFns<TripReplacementPeriod> = {
  encode(message: TripReplacementPeriod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.routeId !== undefined && message.routeId !== "") {
      writer.uint32(10).string(message.routeId);
    }
    if (message.replacementPeriod !== undefined) {
      TimeRange.encode(message.replacementPeriod, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TripReplacementPeriod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTripReplacementPeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.routeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.replacementPeriod = TimeRange.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TripReplacementPeriod {
    return {
      routeId: isSet(object.routeId) ? globalThis.String(object.routeId) : "",
      replacementPeriod: isSet(object.replacementPeriod) ? TimeRange.fromJSON(object.replacementPeriod) : undefined,
    };
  },

  toJSON(message: TripReplacementPeriod): unknown {
    const obj: any = {};
    if (message.routeId !== undefined && message.routeId !== "") {
      obj.routeId = message.routeId;
    }
    if (message.replacementPeriod !== undefined) {
      obj.replacementPeriod = TimeRange.toJSON(message.replacementPeriod);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TripReplacementPeriod>, I>>(base?: I): TripReplacementPeriod {
    return TripReplacementPeriod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TripReplacementPeriod>, I>>(object: I): TripReplacementPeriod {
    const message = createBaseTripReplacementPeriod();
    message.routeId = object.routeId ?? "";
    message.replacementPeriod = (object.replacementPeriod !== undefined && object.replacementPeriod !== null)
      ? TimeRange.fromPartial(object.replacementPeriod)
      : undefined;
    return message;
  },
};

function createBaseNyctFeedHeader(): NyctFeedHeader {
  return { nyctSubwayVersion: "", tripReplacementPeriod: [] };
}

export const NyctFeedHeader: MessageFns<NyctFeedHeader> = {
  encode(message: NyctFeedHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nyctSubwayVersion !== "") {
      writer.uint32(10).string(message.nyctSubwayVersion);
    }
    for (const v of message.tripReplacementPeriod) {
      TripReplacementPeriod.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NyctFeedHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNyctFeedHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nyctSubwayVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tripReplacementPeriod.push(TripReplacementPeriod.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NyctFeedHeader {
    return {
      nyctSubwayVersion: isSet(object.nyctSubwayVersion) ? globalThis.String(object.nyctSubwayVersion) : "",
      tripReplacementPeriod: globalThis.Array.isArray(object?.tripReplacementPeriod)
        ? object.tripReplacementPeriod.map((e: any) => TripReplacementPeriod.fromJSON(e))
        : [],
    };
  },

  toJSON(message: NyctFeedHeader): unknown {
    const obj: any = {};
    if (message.nyctSubwayVersion !== "") {
      obj.nyctSubwayVersion = message.nyctSubwayVersion;
    }
    if (message.tripReplacementPeriod?.length) {
      obj.tripReplacementPeriod = message.tripReplacementPeriod.map((e) => TripReplacementPeriod.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NyctFeedHeader>, I>>(base?: I): NyctFeedHeader {
    return NyctFeedHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NyctFeedHeader>, I>>(object: I): NyctFeedHeader {
    const message = createBaseNyctFeedHeader();
    message.nyctSubwayVersion = object.nyctSubwayVersion ?? "";
    message.tripReplacementPeriod = object.tripReplacementPeriod?.map((e) => TripReplacementPeriod.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseNyctTripDescriptor(): NyctTripDescriptor {
  return { trainId: "", isAssigned: false, direction: 1 };
}

export const NyctTripDescriptor: MessageFns<NyctTripDescriptor> = {
  encode(message: NyctTripDescriptor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trainId !== undefined && message.trainId !== "") {
      writer.uint32(10).string(message.trainId);
    }
    if (message.isAssigned !== undefined && message.isAssigned !== false) {
      writer.uint32(16).bool(message.isAssigned);
    }
    if (message.direction !== undefined && message.direction !== 1) {
      writer.uint32(24).int32(message.direction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NyctTripDescriptor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNyctTripDescriptor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trainId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isAssigned = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NyctTripDescriptor {
    return {
      trainId: isSet(object.trainId) ? globalThis.String(object.trainId) : "",
      isAssigned: isSet(object.isAssigned) ? globalThis.Boolean(object.isAssigned) : false,
      direction: isSet(object.direction) ? nyctTripDescriptor_DirectionFromJSON(object.direction) : 1,
    };
  },

  toJSON(message: NyctTripDescriptor): unknown {
    const obj: any = {};
    if (message.trainId !== undefined && message.trainId !== "") {
      obj.trainId = message.trainId;
    }
    if (message.isAssigned !== undefined && message.isAssigned !== false) {
      obj.isAssigned = message.isAssigned;
    }
    if (message.direction !== undefined && message.direction !== 1) {
      obj.direction = nyctTripDescriptor_DirectionToJSON(message.direction);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NyctTripDescriptor>, I>>(base?: I): NyctTripDescriptor {
    return NyctTripDescriptor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NyctTripDescriptor>, I>>(object: I): NyctTripDescriptor {
    const message = createBaseNyctTripDescriptor();
    message.trainId = object.trainId ?? "";
    message.isAssigned = object.isAssigned ?? false;
    message.direction = object.direction ?? 1;
    return message;
  },
};

function createBaseNyctStopTimeUpdate(): NyctStopTimeUpdate {
  return { scheduledTrack: "", actualTrack: "" };
}

export const NyctStopTimeUpdate: MessageFns<NyctStopTimeUpdate> = {
  encode(message: NyctStopTimeUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scheduledTrack !== undefined && message.scheduledTrack !== "") {
      writer.uint32(10).string(message.scheduledTrack);
    }
    if (message.actualTrack !== undefined && message.actualTrack !== "") {
      writer.uint32(18).string(message.actualTrack);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NyctStopTimeUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNyctStopTimeUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scheduledTrack = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actualTrack = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NyctStopTimeUpdate {
    return {
      scheduledTrack: isSet(object.scheduledTrack) ? globalThis.String(object.scheduledTrack) : "",
      actualTrack: isSet(object.actualTrack) ? globalThis.String(object.actualTrack) : "",
    };
  },

  toJSON(message: NyctStopTimeUpdate): unknown {
    const obj: any = {};
    if (message.scheduledTrack !== undefined && message.scheduledTrack !== "") {
      obj.scheduledTrack = message.scheduledTrack;
    }
    if (message.actualTrack !== undefined && message.actualTrack !== "") {
      obj.actualTrack = message.actualTrack;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NyctStopTimeUpdate>, I>>(base?: I): NyctStopTimeUpdate {
    return NyctStopTimeUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NyctStopTimeUpdate>, I>>(object: I): NyctStopTimeUpdate {
    const message = createBaseNyctStopTimeUpdate();
    message.scheduledTrack = object.scheduledTrack ?? "";
    message.actualTrack = object.actualTrack ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
